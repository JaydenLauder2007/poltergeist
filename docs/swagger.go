package docs

import (
	"encoding/json"
	"fmt"
	"net/http"
	"reflect"
	"strings"

	"github.com/gofuckbiz/poltergeist"
)

// OpenAPI represents the OpenAPI 3.0 specification
type OpenAPI struct {
	OpenAPI    string              `json:"openapi"`
	Info       Info                `json:"info"`
	Servers    []Server            `json:"servers,omitempty"`
	Paths      map[string]PathItem `json:"paths"`
	Components *Components         `json:"components,omitempty"`
	Tags       []Tag               `json:"tags,omitempty"`
}

// Info represents API information
type Info struct {
	Title          string   `json:"title"`
	Description    string   `json:"description,omitempty"`
	TermsOfService string   `json:"termsOfService,omitempty"`
	Contact        *Contact `json:"contact,omitempty"`
	License        *License `json:"license,omitempty"`
	Version        string   `json:"version"`
}

// Contact represents contact information
type Contact struct {
	Name  string `json:"name,omitempty"`
	URL   string `json:"url,omitempty"`
	Email string `json:"email,omitempty"`
}

// License represents license information
type License struct {
	Name string `json:"name"`
	URL  string `json:"url,omitempty"`
}

// Server represents a server
type Server struct {
	URL         string `json:"url"`
	Description string `json:"description,omitempty"`
}

// PathItem represents a path item
type PathItem struct {
	Get     *Operation `json:"get,omitempty"`
	Post    *Operation `json:"post,omitempty"`
	Put     *Operation `json:"put,omitempty"`
	Delete  *Operation `json:"delete,omitempty"`
	Patch   *Operation `json:"patch,omitempty"`
	Options *Operation `json:"options,omitempty"`
	Head    *Operation `json:"head,omitempty"`
}

// Operation represents an API operation
type Operation struct {
	Tags        []string            `json:"tags,omitempty"`
	Summary     string              `json:"summary,omitempty"`
	Description string              `json:"description,omitempty"`
	OperationID string              `json:"operationId,omitempty"`
	Parameters  []Parameter         `json:"parameters,omitempty"`
	RequestBody *RequestBody        `json:"requestBody,omitempty"`
	Responses   map[string]Response `json:"responses"`
	Security    []SecurityReq       `json:"security,omitempty"`
	Deprecated  bool                `json:"deprecated,omitempty"`
}

// Parameter represents a parameter
type Parameter struct {
	Name        string  `json:"name"`
	In          string  `json:"in"` // query, header, path, cookie
	Description string  `json:"description,omitempty"`
	Required    bool    `json:"required,omitempty"`
	Schema      *Schema `json:"schema,omitempty"`
}

// RequestBody represents a request body
type RequestBody struct {
	Description string               `json:"description,omitempty"`
	Content     map[string]MediaType `json:"content"`
	Required    bool                 `json:"required,omitempty"`
}

// Response represents a response
type Response struct {
	Description string               `json:"description"`
	Content     map[string]MediaType `json:"content,omitempty"`
}

// MediaType represents a media type
type MediaType struct {
	Schema *Schema `json:"schema,omitempty"`
}

// Schema represents a schema
type Schema struct {
	Type       string             `json:"type,omitempty"`
	Format     string             `json:"format,omitempty"`
	Items      *Schema            `json:"items,omitempty"`
	Properties map[string]*Schema `json:"properties,omitempty"`
	Required   []string           `json:"required,omitempty"`
	Ref        string             `json:"$ref,omitempty"`
}

// Components represents API components
type Components struct {
	Schemas         map[string]*Schema        `json:"schemas,omitempty"`
	SecuritySchemes map[string]SecurityScheme `json:"securitySchemes,omitempty"`
}

// SecurityScheme represents a security scheme
type SecurityScheme struct {
	Type         string `json:"type"`
	Scheme       string `json:"scheme,omitempty"`
	BearerFormat string `json:"bearerFormat,omitempty"`
	Name         string `json:"name,omitempty"`
	In           string `json:"in,omitempty"`
	Description  string `json:"description,omitempty"`
}

// SecurityReq represents a security requirement
type SecurityReq map[string][]string

// Tag represents an API tag
type Tag struct {
	Name        string `json:"name"`
	Description string `json:"description,omitempty"`
}

// SwaggerConfig holds Swagger UI configuration
type SwaggerConfig struct {
	Title       string
	Description string
	Version     string
	BasePath    string
	Servers     []Server
	Contact     *Contact
	License     *License
}

// DefaultSwaggerConfig returns default Swagger configuration
func DefaultSwaggerConfig() *SwaggerConfig {
	return &SwaggerConfig{
		Title:       "Poltergeist API",
		Description: "API documentation generated by Poltergeist",
		Version:     "1.0.0",
		BasePath:    "/",
		Servers: []Server{
			{URL: "http://localhost:8080", Description: "Development server"},
		},
	}
}

// GenerateOpenAPI generates OpenAPI spec from routes
func GenerateOpenAPI(routes []*poltergeist.Route, config *SwaggerConfig) *OpenAPI {
	if config == nil {
		config = DefaultSwaggerConfig()
	}

	spec := &OpenAPI{
		OpenAPI: "3.0.3",
		Info: Info{
			Title:       config.Title,
			Description: config.Description,
			Version:     config.Version,
			Contact:     config.Contact,
			License:     config.License,
		},
		Servers: config.Servers,
		Paths:   make(map[string]PathItem),
		Components: &Components{
			Schemas:         make(map[string]*Schema),
			SecuritySchemes: make(map[string]SecurityScheme),
		},
	}

	// Track tags
	tagsMap := make(map[string]bool)

	for _, route := range routes {
		path := convertPathToOpenAPI(route.Path)

		// Get or create path item
		pathItem, exists := spec.Paths[path]
		if !exists {
			pathItem = PathItem{}
		}

		// Create operation
		operation := &Operation{
			Tags:        route.RouteTags,
			Summary:     route.RouteName,
			Description: route.RouteDescription,
			OperationID: generateOperationID(route.Method, route.Path),
			Parameters:  extractParameters(route.Path),
			Responses: map[string]Response{
				"200": {Description: "Successful response"},
				"400": {Description: "Bad request"},
				"500": {Description: "Internal server error"},
			},
		}

		// Add request body if present
		if route.RequestBody != nil {
			schema := typeToSchema(reflect.TypeOf(route.RequestBody))
			schemaName := reflect.TypeOf(route.RequestBody).Name()
			if schemaName != "" {
				spec.Components.Schemas[schemaName] = schema
				operation.RequestBody = &RequestBody{
					Content: map[string]MediaType{
						"application/json": {
							Schema: &Schema{Ref: "#/components/schemas/" + schemaName},
						},
					},
				}
			}
		}

		// Add response body if present
		if route.ResponseBody != nil {
			schema := typeToSchema(reflect.TypeOf(route.ResponseBody))
			schemaName := reflect.TypeOf(route.ResponseBody).Name()
			if schemaName != "" {
				spec.Components.Schemas[schemaName] = schema
				operation.Responses["200"] = Response{
					Description: "Successful response",
					Content: map[string]MediaType{
						"application/json": {
							Schema: &Schema{Ref: "#/components/schemas/" + schemaName},
						},
					},
				}
			}
		}

		// Track tags
		for _, tag := range route.RouteTags {
			tagsMap[tag] = true
		}

		// Assign operation to method
		switch route.Method {
		case http.MethodGet:
			pathItem.Get = operation
		case http.MethodPost:
			pathItem.Post = operation
		case http.MethodPut:
			pathItem.Put = operation
		case http.MethodDelete:
			pathItem.Delete = operation
		case http.MethodPatch:
			pathItem.Patch = operation
		case http.MethodOptions:
			pathItem.Options = operation
		case http.MethodHead:
			pathItem.Head = operation
		}

		spec.Paths[path] = pathItem
	}

	// Add tags to spec
	for tag := range tagsMap {
		spec.Tags = append(spec.Tags, Tag{Name: tag})
	}

	return spec
}

// convertPathToOpenAPI converts route path to OpenAPI format
func convertPathToOpenAPI(path string) string {
	parts := strings.Split(path, "/")
	for i, part := range parts {
		if strings.HasPrefix(part, ":") {
			parts[i] = "{" + strings.TrimPrefix(part, ":") + "}"
		}
		if strings.HasPrefix(part, "*") {
			parts[i] = "{" + strings.TrimPrefix(part, "*") + "}"
		}
	}
	return strings.Join(parts, "/")
}

// generateOperationID generates an operation ID from method and path
func generateOperationID(method, path string) string {
	// Convert path to camelCase operation ID
	parts := strings.Split(path, "/")
	var result strings.Builder
	result.WriteString(strings.ToLower(method))
	for _, part := range parts {
		if part == "" {
			continue
		}
		part = strings.TrimPrefix(part, ":")
		part = strings.TrimPrefix(part, "*")
		if len(part) > 0 {
			result.WriteString(strings.ToUpper(part[:1]) + part[1:])
		}
	}
	return result.String()
}

// extractParameters extracts path parameters from route path
func extractParameters(path string) []Parameter {
	var params []Parameter
	parts := strings.Split(path, "/")
	for _, part := range parts {
		if strings.HasPrefix(part, ":") {
			params = append(params, Parameter{
				Name:     strings.TrimPrefix(part, ":"),
				In:       "path",
				Required: true,
				Schema:   &Schema{Type: "string"},
			})
		}
	}
	return params
}

// typeToSchema converts a Go type to OpenAPI schema
func typeToSchema(t reflect.Type) *Schema {
	if t == nil {
		return &Schema{Type: "object"}
	}

	// Handle pointers
	if t.Kind() == reflect.Ptr {
		t = t.Elem()
	}

	switch t.Kind() {
	case reflect.String:
		return &Schema{Type: "string"}
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		return &Schema{Type: "integer"}
	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
		return &Schema{Type: "integer"}
	case reflect.Float32, reflect.Float64:
		return &Schema{Type: "number"}
	case reflect.Bool:
		return &Schema{Type: "boolean"}
	case reflect.Slice, reflect.Array:
		return &Schema{
			Type:  "array",
			Items: typeToSchema(t.Elem()),
		}
	case reflect.Struct:
		props := make(map[string]*Schema)
		var required []string
		for i := 0; i < t.NumField(); i++ {
			field := t.Field(i)
			jsonTag := field.Tag.Get("json")
			if jsonTag == "-" {
				continue
			}
			name := strings.Split(jsonTag, ",")[0]
			if name == "" {
				name = field.Name
			}
			props[name] = typeToSchema(field.Type)

			// Check if required
			if !strings.Contains(jsonTag, "omitempty") {
				required = append(required, name)
			}
		}
		return &Schema{
			Type:       "object",
			Properties: props,
			Required:   required,
		}
	case reflect.Map:
		return &Schema{Type: "object"}
	default:
		return &Schema{Type: "object"}
	}
}

// Swagger returns handlers for Swagger UI
func Swagger(server *poltergeist.Server, config *SwaggerConfig) {
	if config == nil {
		config = DefaultSwaggerConfig()
	}

	// Serve OpenAPI JSON spec
	server.GET("/swagger/doc.json", func(c *poltergeist.Context) error {
		spec := GenerateOpenAPI(server.Routes(), config)
		return c.JSON(http.StatusOK, spec)
	})

	// Serve Swagger UI
	server.GET("/swagger", func(c *poltergeist.Context) error {
		return c.HTML(http.StatusOK, swaggerUIHTML(config.Title))
	})

	server.GET("/swagger/", func(c *poltergeist.Context) error {
		return c.HTML(http.StatusOK, swaggerUIHTML(config.Title))
	})
}

// swaggerUIHTML returns Swagger UI HTML
func swaggerUIHTML(title string) string {
	return fmt.Sprintf(`<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>%s - Swagger UI</title>
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/swagger-ui-dist@5/swagger-ui.css">
    <style>
        html { box-sizing: border-box; overflow-y: scroll; }
        *, *:before, *:after { box-sizing: inherit; }
        body { margin: 0; background: #fafafa; }
        .swagger-ui .topbar { display: none; }
        .swagger-ui .info { margin: 20px 0; }
        .swagger-ui .info .title { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; }
    </style>
</head>
<body>
    <div id="swagger-ui"></div>
    <script src="https://cdn.jsdelivr.net/npm/swagger-ui-dist@5/swagger-ui-bundle.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/swagger-ui-dist@5/swagger-ui-standalone-preset.js"></script>
    <script>
        window.onload = function() {
            window.ui = SwaggerUIBundle({
                url: "/swagger/doc.json",
                dom_id: '#swagger-ui',
                deepLinking: true,
                presets: [
                    SwaggerUIBundle.presets.apis,
                    SwaggerUIStandalonePreset
                ],
                plugins: [
                    SwaggerUIBundle.plugins.DownloadUrl
                ],
                layout: "StandaloneLayout",
                validatorUrl: null,
                supportedSubmitMethods: ['get', 'post', 'put', 'delete', 'patch', 'options', 'head']
            });
        };
    </script>
</body>
</html>`, title)
}

// ExportJSON exports OpenAPI spec to JSON
func ExportJSON(routes []*poltergeist.Route, config *SwaggerConfig) ([]byte, error) {
	spec := GenerateOpenAPI(routes, config)
	return json.MarshalIndent(spec, "", "  ")
}
